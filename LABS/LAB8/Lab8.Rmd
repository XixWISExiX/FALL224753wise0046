---
title: "Lab8"
author: "Joshua Wiseman"
date: '`r format(Sys.Date(),format="%A, %B %d, %Y")`'
output: 
  html_document:
    df_print: paged
    fig_caption: true
    highlights: pygments
    number_sections: no
    theme: spacelab
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

![](https://media.giphy.com/media/D10hKcRT6JaLu/giphy.gif)

# Task 1

## Working Directory
```{r}
getwd()
```

# Task 2

## runif(10,0,5)
```{r}
sample = runif(10,0,5)
sample
```

## Mean + Variance of uniform
```{r}
# Mean
mu = (0+5)/2
mu

# Variance
var = (5-0)^2/12
var
```

## Mean + Variance of population
```{r}
# Mean
x_hat = mean(sample)
x_hat

# Variance
s_squ = var(sample)
s_squ
```

## Sum T
```{r}
n = length(sample)

# Mean
T_mean = n * x_hat
T_mean

# Variance
T_var = n * s_squ
T_var
```

## $\bar{Y}$ mean
```{r}
# Mean
Y_mean = mu
Y_mean

# Variance
Y_var = s_squ / n
Y_var
```

## Explaination
```{r}
myclt=function(n,iter){
y=runif(n*iter,0,5) # A
data=matrix(y,nr=n,nc=iter,byrow=TRUE) #B
sm=apply(data,2,sum) #C
hist(sm)
sm
}
w=myclt(n=10,iter=10000) #D
```

A is the assigning y with the a uniform distribution of sise (n) * iterations along with a value being 0 and b value being 5.

B is making a matrix with the uniform distribution making the number of rows n in length and the number of columns the number of iterations in length. Displayed by rows.

C is the applying the matrix with Margin = 2 and the sum resulting in getting the col.sums

D is calling the function myclt to have a length of n = 10 and iterations = 10000. 

## $\bar{w} \wedge s^2_w$
```{r}
# Mean
mean(w)

# Variance
var(w)
```

## Changed myclt
```{r}
myclt=function(n,iter){
y=runif(n*iter,0,5) # A
data=matrix(y,nr=n,nc=iter,byrow=TRUE) #B
sm=apply(data,2,sum) #C
h=hist(sm,plot=FALSE)
hist(sm,col=rainbow(length(h$mids)),freq=FALSE,main="Distribution of the sum of uniforms")
curve(dnorm(x,mean=n*(5)/2,sd=sqrt(n*(5)^2/12)),add=TRUE,lwd=2,col="Blue")
sm
}
w=myclt(n=10,iter=10000) #D
```

# Task 3

## mycltu()
```{r}
################### uniform ##########################
### CLT uniform 
## my Central Limit Function
## Notice that I have assigned default values which can be changed when the function is called
mycltu=function(n,iter,a=0,b=10){
## r-random sample from the uniform
y=runif(n*iter,a,b)
## Place these numbers into a matrix
## The columns will correspond to the iteration and the rows will equal the sample size n
data=matrix(y,nr=n,nc=iter,byrow=TRUE)
## apply the function mean to the columns (2) of the matrix
## these are placed in a vector w
w=apply(data,2,mean)
## We will make a histogram of the values in w
## How high should we make y axis?
## All the values used to make a histogram are placed in param (nothing is plotted yet)
param=hist(w,plot=FALSE)
## Since the histogram will be a density plot we will find the max density

ymax=max(param$density)
## To be on the safe side we will add 10% more to this
ymax=1.1*ymax
## Now we can make the histogram
hist(w,freq=FALSE,  ylim=c(0,ymax), main=paste("Histogram of sample mean",
"\n", "sample size= ",n,sep=""),xlab="Sample mean")
## add a density curve made from the sample distribution
lines(density(w),col="Blue",lwd=3) # add a density plot
## Add a theoretical normal curve 
curve(dnorm(x,mean=(a+b)/2,sd=(b-a)/(sqrt(12*n))),add=TRUE,col="Red",lty=2,lwd=3) # add a theoretical curve
## Add the density from which the samples were taken
curve(dunif(x,a,b),add=TRUE,lwd=4)

}
mycltu(n=20,iter=100000)
```

## Examine

w=apply(data,2,mean), how does the apply function use the 2?
`apply the mean function to each column of matrix`

How many terms are in w, when mycltu(n=20,iter=100000) is called?
```{r}
20 * 100000
```

curve(dnorm(x,mean=(a+b)/2, sd=(b-a)/(sqrt(12*n))),add=TRUE,col="Red",lty=2,lwd=3):
`graph the curve of the distribution of the given mean and variance with the use of sd`

## Record Plots
```{r}
mycltu(n=1,iter=10000)
mycltu(n=2,iter=10000)
mycltu(n=3,iter=10000)
mycltu(n=5,iter=10000)
mycltu(n=10,iter=10000)
mycltu(n=30,iter=10000)
```

I conclude that the function becomes more like a normal distribution the more iterations and the greater n is in size.

# Task 4

## mycltb()
```{r}
##############################  Binomial #########


## CLT Binomial
## CLT will work with discrete or continuous distributions 
## my Central Limit Function
## Notice that I have assigned default values which can be changed when the function is called

mycltb=function(n,iter,p=0.5,...){

## r-random sample from the Binomial
y=rbinom(n*iter,size=n,prob=p)
## Place these numbers into a matrix
## The columns will correspond to the iteration and the rows will equal the sample size n
data=matrix(y,nr=n,nc=iter,byrow=TRUE)
## apply the function mean to the columns (2) of the matrix
## these are placed in a vector w
w=apply(data,2,mean)
## We will make a histogram of the values in w
## How high should we make y axis?
## All the values used to make a histogram are placed in param (nothing is plotted yet)
param=hist(w,plot=FALSE)
## Since the histogram will be a density plot we will find the max density

ymax=max(param$density)
## To be on the safe side we will add 10% more to this
ymax=1.1*ymax

## Now we can make the histogram
## freq=FALSE means take a density
hist(w,freq=FALSE,  ylim=c(0,ymax),
main=paste("Histogram of sample mean","\n", "sample size= ",n,sep=""),
xlab="Sample mean",...)
## add a density curve made from the sample distribution
#lines(density(w),col="Blue",lwd=3) # add a density plot
## Add a theoretical normal curve 
curve(dnorm(x,mean=n*p,sd=sqrt(p*(1-p))),add=TRUE,col="Red",lty=2,lwd=3) 

}


mycltb(n=5,iter=10000,p=0.5)
```

## Graphs with p=0.3
```{r}
mycltb(n=4,iter=10000,p=0.3)
mycltb(n=5,iter=10000,p=0.3)
mycltb(n=10,iter=10000,p=0.3)
mycltb(n=20,iter=10000,p=0.3)
```

## Graphs with p=0.7
```{r}
mycltb(n=4,iter=10000,p=0.7)
mycltb(n=5,iter=10000,p=0.7)
mycltb(n=10,iter=10000,p=0.7)
mycltb(n=20,iter=10000,p=0.7)
```

## Graphs with p=0.5
```{r}
mycltb(n=4,iter=10000,p=0.5)
mycltb(n=5,iter=10000,p=0.5)
mycltb(n=10,iter=10000,p=0.5)
mycltb(n=20,iter=10000,p=0.5)
```

I conclude that the function becomes more like a normal distribution the more iterations and the greater n is in size like previously. However, because the p value is changing, after enough iterations it will skew towards the percentage or p value.

# Task 5 

## Recording
<video width="320" height="240" controls>
  <source src="Lab8.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>

## mycltp()
```{r}
####### Poisson ######################

## CLT Poisson
## CLT will work with discrete or continuous distributions 
## my Central Limit Function
## Notice that I have assigned default values which can be changed when the function is called

mycltp=function(n,iter,lambda=10,...){

## r-random sample from the Poisson
y=rpois(n*iter,lambda=lambda)
## Place these numbers into a matrix
## The columns will correspond to the iteration and the rows will equal the sample size n
data=matrix(y,nr=n,nc=iter,byrow=TRUE)
## apply the function mean to the columns (2) of the matrix
## these are placed in a vector w
w=apply(data,2,mean)
## We will make a histogram of the values in w
## How high should we make y axis?
## All the values used to make a histogram are placed in param (nothing is plotted yet)
param=hist(w,plot=FALSE)
## Since the histogram will be a density plot we will find the max density

ymax=max(param$density)
## To be on the safe side we will add 10% more to this
ymax=1.1*ymax

## Make a suitable layout for graphing
layout(matrix(c(1,1,2,3),nr=2,nc=2, byrow=TRUE))

## Now we can make the histogram
hist(w,freq=FALSE,  ylim=c(0,ymax), col=rainbow(max(w)),
main=paste("Histogram of sample mean","\n", "sample size= ",n," iter=",iter," lambda=",lambda,sep=""),
xlab="Sample mean",...)
## add a density curve made from the sample distribution
#lines(density(w),col="Blue",lwd=3) # add a density plot
## Add a theoretical normal curve 
curve(dnorm(x,mean=lambda,sd=sqrt(lambda/n)),add=TRUE,col="Red",lty=2,lwd=3) # add a theoretical curve

# Now make a new plot
# Since y is discrete we should use a barplot
barplot(table(y)/(n*iter),col=rainbow(max(y)), main="Barplot of sampled y", ylab ="Rel. Freq",xlab="y" )
x=0:max(y)
plot(x,dpois(x,lambda=lambda),type="h",lwd=5,col=rainbow(max(y)),
main="Probability function for Poisson", ylab="Probability",xlab="y")
}


mycltp(n=10,iter=10000)
```

## Graphs with lambda=4
```{r}
mycltp(n=2,iter=10000,lambda=4)
mycltp(n=3,iter=10000,lambda=4)
mycltp(n=5,iter=10000,lambda=4)
mycltp(n=10,iter=10000,lambda=4)
mycltp(n=20,iter=10000,lambda=4)
```

## Graphs with lambda=10
```{r}
mycltp(n=2,iter=10000,lambda=10)
mycltp(n=3,iter=10000,lambda=10)
mycltp(n=5,iter=10000,lambda=10)
mycltp(n=10,iter=10000,lambda=10)
mycltp(n=20,iter=10000,lambda=10)
```

# Task 6

## Uniform Distribution Function Package
```{r}
BestRPackage::cltu(n=20,iter=100000)
```

# Task 7

## mycltp() change
```{r}
####### Poisson ######################

## CLT Poisson
## CLT will work with discrete or continuous distributions 
## my Central Limit Function
## Notice that I have assigned default values which can be changed when the function is called

mycltp=function(n,iter,lambda=10,...){

## r-random sample from the Poisson
y=rpois(n*iter,lambda=lambda)
## Place these numbers into a matrix
## The columns will correspond to the iteration and the rows will equal the sample size n
data=matrix(y,nr=n,nc=iter,byrow=TRUE)
## apply the function mean to the columns (2) of the matrix
## these are placed in a vector w
w=apply(data,2,sum)
## We will make a histogram of the values in w
## How high should we make y axis?
## All the values used to make a histogram are placed in param (nothing is plotted yet)
param=hist(w,plot=FALSE)
## Since the histogram will be a density plot we will find the max density

ymax=max(param$density)
## To be on the safe side we will add 10% more to this
ymax=1.1*ymax

## Make a suitable layout for graphing
layout(matrix(c(1,1,2,3),nr=2,nc=2, byrow=TRUE))

## Now we can make the histogram
hist(w,freq=FALSE,  ylim=c(0,ymax), col=rainbow(max(w)),
main=paste("Histogram of sample sum","\n", "sample size= ",n," iter=",iter," lambda=",lambda,sep=""),
xlab="Sample mean",...)
## add a density curve made from the sample distribution
#lines(density(w),col="Blue",lwd=3) # add a density plot
## Add a theoretical normal curve 
curve(dnorm(x,mean=lambda,sd=sqrt(lambda/n)),add=TRUE,col="Red",lty=2,lwd=3) # add a theoretical curve

# Now make a new plot
# Since y is discrete we should use a barplot
barplot(table(y)/(n*iter),col=rainbow(max(y)), main="Barplot of sampled y", ylab ="Rel. Freq",xlab="y" )
x=0:max(y)
plot(x,dpois(x,lambda=lambda),type="h",lwd=5,col=rainbow(max(y)),
main="Probability function for Poisson", ylab="Probability",xlab="y")
}


mycltp(n=10,iter=10000)
```
